{"version":3,"sources":["webpack://dagre/webpack/universalModuleDefinition","webpack://dagre/webpack/bootstrap","webpack://dagre/external \"lodash\"","webpack://dagre/./lib/util.js","webpack://dagre/external \"graphlibrary\"","webpack://dagre/./lib/rank/util.js","webpack://dagre/./lib/rank/feasible-tree.js","webpack://dagre/./lib/position/bk.js","webpack://dagre/./lib/position/index.js","webpack://dagre/./lib/order/add-subgraph-constraints.js","webpack://dagre/./lib/order/build-layer-graph.js","webpack://dagre/./lib/order/sort.js","webpack://dagre/./lib/order/resolve-conflicts.js","webpack://dagre/./lib/order/barycenter.js","webpack://dagre/./lib/order/sort-subgraph.js","webpack://dagre/./lib/order/cross-count.js","webpack://dagre/./lib/order/init-order.js","webpack://dagre/./lib/order/index.js","webpack://dagre/./lib/coordinate-system.js","webpack://dagre/./lib/add-border-segments.js","webpack://dagre/./lib/nesting-graph.js","webpack://dagre/./lib/parent-dummy-chains.js","webpack://dagre/./lib/rank/network-simplex.js","webpack://dagre/./lib/rank/index.js","webpack://dagre/./lib/normalize.js","webpack://dagre/./lib/data/list.js","webpack://dagre/./lib/greedy-fas.js","webpack://dagre/./lib/acyclic.js","webpack://dagre/./lib/layout.js","webpack://dagre/./index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","require","addDummyNode","simplify","asNonCompoundGraph","successorWeights","predecessorWeights","intersectRect","buildLayerMatrix","normalizeRanks","removeEmptyRanks","addBorderNode","maxRank","partition","time","notime","_lodash","_graphlibrary","g","type","attrs","v","_lodash2","default","uniqueId","hasNode","dummy","setNode","simplified","Graph","setGraph","graph","forEach","nodes","node","edges","e","simpleLabel","edge","w","weight","minlen","label","setEdge","Math","max","multigraph","isMultigraph","children","length","weightMap","map","sucs","outEdges","zipObject","preds","inEdges","rect","point","x","y","dx","dy","width","h","height","Error","sx","sy","abs","layering","range","rank","isUndefined","order","min","has","offset","layers","push","delta","nodeRankFactor","vs","prefix","arguments","collection","fn","result","lhs","rhs","start","now","console","log","longestPath","slack","visited","sources","dfs","_util","tightTree","t","nodeEdges","edgeV","nodeCount","findMinSlackEdge","minBy","shiftRanks","directed","size","positionX","findType1Conflicts","conflicts","reduce","prevLayer","layer","k0","scanPos","prevLayerLength","lastNode","last","find","predecessors","u","findOtherInnerSegmentNode","k1","slice","scanNode","uLabel","uPos","addConflict","findType2Conflicts","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","uNode","north","prevNorthPos","nextNorthPos","southLookahead","tmp","conflictsV","hasConflict","verticalAlignment","neighborFn","align","pos","prevIdx","ws","mp","sortBy","floor","il","ceil","horizontalCompaction","reverseSep","xs","blockG","blockGraph","graphLabel","sepFn","nodeSep","edgeSep","vLabel","wLabel","sum","labelpos","toLowerCase","sep","nodesep","edgesep","vRoot","uRoot","prevMax","buildBlockGraph","pass1","borderType","pass2","Number","POSITIVE_INFINITY","findSmallestWidthAlignment","xss","values","toPairs","pair","maxBy","alignCoordinates","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","xsVals","mapValues","balance","ul","ignore","_util2","merge","adjustedLayering","reverse","inner","bind","successors","smallestWidth","_bk","rankSep","ranksep","prevY","maxHeight","positionY","cg","prev","rootPrev","child","parent","prevChild","relationship","createRootNode","compound","setDefaultNodeLabel","minRank","setParent","borderLeft","borderRight","consumeUnsortable","unsortable","index","pop","entries","biasRight","bias","parts","entry","sortable","vsIndex","sort","entryV","entryW","barycenter","flatten","mappedEntries","indegree","in","out","sourceSet","handleIn","vEntry","uEntry","target","source","merged","concat","handleOut","wEntry","chain","filter","pick","doResolveConflicts","movable","inV","acc","nodeU","sortSubgraph","bl","undefined","br","subgraphs","barycenters","_barycenter2","subgraphResult","other","_resolveConflicts2","expandSubgraphs","_sort2","blPred","brPred","twoLayerCrossCount","northLayer","southLayer","southEntries","firstIndex","treeSize","tree","Array","cc","weightSum","simpleNodes","orderedVs","buildLayerGraphs","ranks","_buildLayerGraph2","sweepLayerGraphs","layerGraphs","lg","sorted","_sortSubgraph2","_addSubgraphConstraints2","assignOrder","downLayerGraphs","upLayerGraphs","_initOrder2","bestCC","best","lastBest","_crossCount2","cloneDeep","swapWidthHeight","swapWidthHeightOne","reverseYOne","swapXYOne","adjust","rankDir","rankdir","undo","points","reverseY","swapXY","prop","sg","sgNode","curr","run","depths","depth","treeDepths","nestingRoot","sumWeights","top","bottom","borderTop","borderBottom","childNode","childTop","childBottom","thisWeight","nestingEdge","cleanup","removeNode","removeEdge","postorderNums","lim","low","postorder","dummyChains","edgeObj","pathData","vPath","wPath","lca","path","findPath","pathIdx","pathV","ascending","preorder","networkSimplex","_feasibleTree2","initLowLimValues","initCutValues","leaveEdge","exchangeEdges","enterEdge","cutvalue","calcCutValue","assignCutValue","childIsTail","graphEdge","cutValue","isOutEdge","pointsToHead","otherWeight","hasEdge","otherCutValue","dfsAssignLowLim","nextLim","neighbors","tailLabel","flip","candidates","isDescendant","f","flipped","updateRanks","rootLabel","longestPathRanker","networkSimplexRanker","_networkSimplex2","ranker","tightTreeRanker","vRank","wRank","edgeLabel","labelRank","normalizeEdge","origLabel","List","sentinel","_next","_prev","this","_sentinel","unlink","filterOutLinks","k","dequeue","enqueue","toString","strs","JSON","stringify","join","DEFAULT_WEIGHT_FN","constant","buckets","zeroIdx","collectPredecessors","results","assignBucket","weightFn","state","fasGraph","maxIn","maxOut","prevWeight","edgeWeight","_list2","buildState","sinks","doGreedyFAS","fas","acyclicer","_greedyFas2","stack","dfsFAS","forwardName","reversed","graphNumAttrs","graphDefaults","graphAttrs","nodeNumAttrs","nodeDefaults","edgeNumAttrs","edgeDefaults","labeloffset","edgeAttrs","selectNumberAttrs","obj","canonicalize","newAttrs","opts","debugTiming","layoutGraph","inputGraph","defaults","buildLayoutGraph","makeSpaceForEdgeLabels","selfEdges","removeSelfEdges","_acyclic2","_nestingGraph2","_rank2","injectEdgeLabelProxies","assignRankMinMax","removeEdgeLabelProxies","_normalize2","_parentDummyChains2","_addBorderSegments2","_order2","orderShift","selfEdge","insertSelfEdges","_coordinateSystem2","_position2","selfNode","positionSelfEdges","b","removeBorderNodes","fixupEdgeLabelCoords","minX","maxX","minY","maxY","marginX","marginx","marginY","marginy","getExtremes","translateGraph","nodeV","nodeW","p1","p2","unshift","assignNodeIntersects","reversePointsForReversedEdges","runLayout","inputLabel","layoutLabel","updateInputGraph","_layout","layout"],"mappings":"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","file":"dagre-layout.core.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dagre\"] = factory();\n\telse\n\t\troot[\"dagre\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n","module.exports = require(\"lodash\");","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nexport function addDummyNode (g, type, attrs, name) {\n  let v\n  do {\n    v = _.uniqueId(name)\n  } while (g.hasNode(v))\n\n  attrs.dummy = type\n  g.setNode(v, attrs)\n  return v\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nexport function simplify (g) {\n  const simplified = new Graph().setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) { simplified.setNode(v, g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 }\n    const label = g.edge(e)\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    })\n  })\n  return simplified\n}\n\nexport function asNonCompoundGraph (g) {\n  const simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v))\n    }\n  })\n  _.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e))\n  })\n  return simplified\n}\n\nexport function successorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const sucs = {}\n    _.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight\n    })\n    return sucs\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\nexport function predecessorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const preds = {}\n    _.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight\n    })\n    return preds\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nexport function intersectRect (rect, point) {\n  const x = rect.x\n  const y = rect.y\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = point.x - x\n  const dy = point.y - y\n  let w = rect.width / 2\n  let h = rect.height / 2\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle')\n  }\n\n  let sx\n  let sy\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h\n    }\n    sx = h * dx / dy\n    sy = h\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w\n    }\n    sx = w\n    sy = w * dy / dx\n  }\n\n  return { x: x + sx, y: y + sy }\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nexport function buildLayerMatrix (g) {\n  const layering = _.map(_.range(maxRank(g) + 1), function () { return [] })\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const rank = node.rank\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v\n    }\n  })\n  return layering\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nexport function normalizeRanks (g) {\n  const min = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (_.has(node, 'rank')) {\n      node.rank -= min\n    }\n  })\n}\n\nexport function removeEmptyRanks (g) {\n  // Ranks may not start at 0, so we need to offset them\n  const offset = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n\n  const layers = []\n  _.forEach(g.nodes(), function (v) {\n    const rank = g.node(v).rank - offset\n    if (!layers[rank]) {\n      layers[rank] = []\n    }\n    layers[rank].push(v)\n  })\n\n  let delta = 0\n  const nodeRankFactor = g.graph().nodeRankFactor\n  _.forEach(layers, function (vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta\n    } else if (delta) {\n      _.forEach(vs, function (v) { g.node(v).rank += delta })\n    }\n  })\n}\n\nexport function addBorderNode (g, prefix, rank, order) {\n  const node = {\n    width: 0,\n    height: 0\n  }\n  if (arguments.length >= 4) {\n    node.rank = rank\n    node.order = order\n  }\n  return addDummyNode(g, 'border', node, prefix)\n}\n\nexport function maxRank (g) {\n  return _.max(_.map(g.nodes(), function (v) {\n    const rank = g.node(v).rank\n    if (!_.isUndefined(rank)) {\n      return rank\n    }\n  }))\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nexport function partition (collection, fn) {\n  const result = { lhs: [], rhs: [] }\n  _.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value)\n    } else {\n      result.rhs.push(value)\n    }\n  })\n  return result\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nexport function time (name, fn) {\n  const start = _.now()\n  try {\n    return fn()\n  } finally {\n    console.log(name + ' time: ' + (_.now() - start) + 'ms')\n  }\n}\n\nexport function notime (name, fn) {\n  return fn()\n}\n\nexport default {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime\n}\n","module.exports = require(\"graphlibrary\");","import _ from 'lodash'\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nexport function longestPath (g) {\n  const visited = {}\n\n  function dfs (v) {\n    const label = g.node(v)\n    if (_.has(visited, v)) {\n      return label.rank\n    }\n    visited[v] = true\n\n    const rank = _.min(_.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen\n    })) || 0\n\n    return (label.rank = rank)\n  }\n\n  _.forEach(g.sources(), dfs)\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nexport function slack (g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen\n}\n\nexport default {\n  longestPath: longestPath,\n  slack: slack\n}\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport { slack } from './util'\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree (g) {\n  const t = new Graph({ directed: false })\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0]\n  const size = g.nodeCount()\n  t.setNode(start, {})\n\n  let edge\n  let delta\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g)\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge)\n    shiftRanks(t, g, delta)\n  }\n\n  return t\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree (t, g) {\n  function dfs (v) {\n    _.forEach(g.nodeEdges(v), function (e) {\n      const edgeV = e.v\n      const w = (v === edgeV) ? e.w : edgeV\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {})\n        t.setEdge(v, w, {})\n        dfs(w)\n      }\n    })\n  }\n\n  _.forEach(t.nodes(), dfs)\n  return t.nodeCount()\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge (t, g) {\n  return _.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e)\n    }\n  })\n}\n\nfunction shiftRanks (t, g, delta) {\n  _.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta\n  })\n}\n\nexport default feasibleTree\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport util from '../util'\n\n/*\n * This module provides coordinate assignment based on Brandes and Kpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts (g, layering) {\n  const conflicts = {}\n\n  function visitLayer (prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0\n    const prevLayerLength = prevLayer.length\n    const lastNode = _.last(layer)\n\n    _.forEach(layer, function (v, i) {\n      const w = findOtherInnerSegmentNode(g, v)\n      const k1 = w ? g.node(w).order : prevLayerLength\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            const uLabel = g.node(u)\n            const uPos = uLabel.order\n            if ((uPos < k0 || k1 < uPos) &&\n              !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode)\n            }\n          })\n        })\n        scanPos = i + 1\n        k0 = k1\n      }\n    })\n\n    return layer\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findType2Conflicts (g, layering) {\n  const conflicts = {}\n\n  function scan (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    let v\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i]\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          const uNode = g.node(u)\n          if (uNode.dummy &&\n            (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v)\n          }\n        })\n      }\n    })\n  }\n\n  function visitLayer (north, south) {\n    let prevNorthPos = -1\n    let nextNorthPos\n    let southPos = 0\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        const predecessors = g.predecessors(v)\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos)\n          southPos = southLookahead\n          prevNorthPos = nextNorthPos\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length)\n    })\n\n    return south\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findOtherInnerSegmentNode (g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy\n    })\n  }\n}\n\nfunction addConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n\n  let conflictsV = conflicts[v]\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {}\n  }\n  conflictsV[w] = true\n}\n\nfunction hasConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n  return _.has(conflicts[v], w)\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment (g, layering, conflicts, neighborFn) {\n  const root = {}\n  const align = {}\n  const pos = {}\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v\n      align[v] = v\n      pos[v] = order\n    })\n  })\n\n  _.forEach(layering, function (layer) {\n    let prevIdx = -1\n    _.forEach(layer, function (v) {\n      let ws = neighborFn(v)\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) { return pos[w] })\n        const mp = (ws.length - 1) / 2\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i]\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v\n            align[v] = root[v] = root[w]\n            prevIdx = pos[w]\n          }\n        }\n      }\n    })\n  })\n\n  return { root: root, align: align }\n}\n\nfunction horizontalCompaction (g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs = {}\n  const blockG = buildBlockGraph(g, layering, root, reverseSep)\n\n  // First pass, assign smallest coordinates via DFS\n  const visited = {}\n  function pass1 (v) {\n    if (!_.has(visited, v)) {\n      visited[v] = true\n      xs[v] = _.reduce(blockG.inEdges(v), function (max, e) {\n        pass1(e.v)\n        return Math.max(max, xs[e.v] + blockG.edge(e))\n      }, 0)\n    }\n  }\n  _.forEach(blockG.nodes(), pass1)\n\n  const borderType = reverseSep ? 'borderLeft' : 'borderRight'\n  function pass2 (v) {\n    if (visited[v] !== 2) {\n      visited[v]++\n      const node = g.node(v)\n      const min = _.reduce(blockG.outEdges(v), function (min, e) {\n        pass2(e.w)\n        return Math.min(min, xs[e.w] - blockG.edge(e))\n      }, Number.POSITIVE_INFINITY)\n      if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n        xs[v] = Math.max(xs[v], min)\n      }\n    }\n  }\n  _.forEach(blockG.nodes(), pass2)\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]]\n  })\n\n  return xs\n}\n\nfunction buildBlockGraph (g, layering, root, reverseSep) {\n  const blockGraph = new Graph()\n  const graphLabel = g.graph()\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep)\n\n  _.forEach(layering, function (layer) {\n    let u\n    _.forEach(layer, function (v) {\n      const vRoot = root[v]\n      blockGraph.setNode(vRoot)\n      if (u) {\n        const uRoot = root[u]\n        const prevMax = blockGraph.edge(uRoot, vRoot)\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0))\n      }\n      u = v\n    })\n  })\n\n  return blockGraph\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment (g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    const min = (_.minBy(_.toPairs(xs), (pair) => pair[1] - width(g, pair[0]) / 2) || ['k', 0])[1]\n    const max = (_.maxBy(_.toPairs(xs), (pair) => pair[1] + width(g, pair[0]) / 2) || ['k', 0])[1]\n    return max - min\n  })\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates (xss, alignTo) {\n  const alignToVals = _.values(alignTo)\n  const alignToMin = _.min(alignToVals)\n  const alignToMax = _.max(alignToVals)\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      const alignment = vert + horiz\n      const xs = xss[alignment]\n      if (xs === alignTo) {\n        return\n      }\n      const xsVals = _.values(xs)\n      const delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals)\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) { return x + delta })\n      }\n    })\n  })\n}\n\nfunction balance (xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v]\n    } else {\n      const xs = _.sortBy(_.map(xss, v))\n      return (xs[1] + xs[2]) / 2\n    }\n  })\n}\n\nexport function positionX (g) {\n  const layering = util.buildLayerMatrix(g)\n  const conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering))\n\n  const xss = {}\n  let adjustedLayering\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse()\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse()\n        })\n      }\n\n      const neighborFn = _.bind(vert === 'u' ? g.predecessors : g.successors, g)\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn)\n      let xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align,\n        horiz === 'r')\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) { return -x })\n      }\n      xss[vert + horiz] = xs\n    })\n  })\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss)\n  alignCoordinates(xss, smallestWidth)\n  return balance(xss, g.graph().align)\n}\n\nfunction sep (nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    const vLabel = g.node(v)\n    const wLabel = g.node(w)\n    let sum = 0\n    let delta\n\n    sum += vLabel.width / 2\n    if (_.has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l': delta = -vLabel.width / 2; break\n        case 'r': delta = vLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2\n\n    sum += wLabel.width / 2\n    if (_.has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l': delta = wLabel.width / 2; break\n        case 'r': delta = -wLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    return sum\n  }\n}\n\nfunction width (g, v) {\n  return g.node(v).width\n}\n\nexport default {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n}\n","import _ from 'lodash'\n\nimport util from '../util'\nimport { positionX } from './bk'\n\nfunction position (g) {\n  g = util.asNonCompoundGraph(g)\n\n  positionY(g)\n  _.forEach(positionX(g), function (x, v) {\n    g.node(v).x = x\n  })\n}\n\nfunction positionY (g) {\n  const layering = util.buildLayerMatrix(g)\n  const rankSep = g.graph().ranksep\n  let prevY = 0\n  _.forEach(layering, function (layer) {\n    const maxHeight = _.max(_.map(layer, function (v) { return g.node(v).height }))\n    _.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2\n    })\n    prevY += maxHeight + rankSep\n  })\n}\n\nexport default position\n","import _ from 'lodash'\n\nfunction addSubgraphConstraints (g, cg, vs) {\n  const prev = {}\n  let rootPrev\n\n  _.forEach(vs, function (v) {\n    let child = g.parent(v)\n    let parent\n    let prevChild\n    while (child) {\n      parent = g.parent(child)\n      if (parent) {\n        prevChild = prev[parent]\n        prev[parent] = child\n      } else {\n        prevChild = rootPrev\n        rootPrev = child\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child)\n        return\n      }\n      child = parent\n    }\n  })\n\n  /*\n  function dfs(v) {\n    const children = v ? g.children(v) : g.children();\n    if (children.length) {\n      const min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.forEach(children, function(child) {\n        const childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\nexport default addSubgraphConstraints\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph (g, rank, relationship) {\n  const root = createRootNode(g)\n  const result = new Graph({ compound: true }).setGraph({ root: root })\n    .setDefaultNodeLabel(function (v) { return g.node(v) })\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const parent = g.parent(v)\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v)\n      result.setParent(v, parent || root)\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        const u = e.v === v ? e.w : e.v\n        const edge = result.edge(u, v)\n        const weight = !_.isUndefined(edge) ? edge.weight : 0\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight })\n      })\n\n      if (_.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        })\n      }\n    }\n  })\n\n  return result\n}\n\nfunction createRootNode (g) {\n  let v\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v\n}\n\nexport default buildLayerGraph\n","import _ from 'lodash'\n\nimport util from '../util'\n\nfunction sort (entries, biasRight) {\n  const parts = util.partition(entries, function (entry) {\n    return _.has(entry, 'barycenter')\n  })\n  const sortable = parts.lhs\n  const unsortable = _.sortBy(parts.rhs, function (entry) { return -entry.i })\n  const vs = []\n  let sum = 0\n  let weight = 0\n  let vsIndex = 0\n\n  sortable.sort(compareWithBias(!!biasRight))\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length\n    vs.push(entry.vs)\n    sum += entry.barycenter * entry.weight\n    weight += entry.weight\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n  })\n\n  const result = { vs: _.flatten(vs, true) }\n  if (weight) {\n    result.barycenter = sum / weight\n    result.weight = weight\n  }\n  return result\n}\n\nfunction consumeUnsortable (vs, unsortable, index) {\n  let last\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop()\n    vs.push(last.vs)\n    index++\n  }\n  return index\n}\n\nfunction compareWithBias (bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i\n  }\n}\n\nexport default sort\n","import _ from 'lodash'\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts (entries, cg) {\n  const mappedEntries = {}\n  _.forEach(entries, function (entry, i) {\n    const tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      'in': [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    }\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter\n      tmp.weight = entry.weight\n    }\n  })\n\n  _.forEach(cg.edges(), function (e) {\n    const entryV = mappedEntries[e.v]\n    const entryW = mappedEntries[e.w]\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++\n      entryV.out.push(mappedEntries[e.w])\n    }\n  })\n\n  const sourceSet = _.filter(mappedEntries, function (entry) {\n    return !entry.indegree\n  })\n\n  return doResolveConflicts(sourceSet)\n}\n\nfunction doResolveConflicts (sourceSet) {\n  const entries = []\n\n  function handleIn (vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry)\n      }\n    }\n  }\n\n  function handleOut (vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry)\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry)\n      }\n    }\n  }\n\n  while (sourceSet.length) {\n    const entry = sourceSet.pop()\n    entries.push(entry)\n    _.forEach(entry['in'].reverse(), handleIn(entry))\n    _.forEach(entry.out, handleOut(entry))\n  }\n\n  return _.chain(entries)\n    .filter(function (entry) { return !entry.merged })\n    .map(function (entry) {\n      return _.pick(entry, ['vs', 'i', 'barycenter', 'weight'])\n    })\n    .value()\n}\n\nfunction mergeEntries (target, source) {\n  let sum = 0\n  let weight = 0\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight\n    weight += target.weight\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight\n    weight += source.weight\n  }\n\n  target.vs = source.vs.concat(target.vs)\n  target.barycenter = sum / weight\n  target.weight = weight\n  target.i = Math.min(source.i, target.i)\n  source.merged = true\n}\n\nexport default resolveConflicts\n","import _ from 'lodash'\n\nfunction barycenter (g, movable) {\n  return _.map(movable, function (v) {\n    const inV = g.inEdges(v)\n    if (!inV.length) {\n      return { v: v }\n    } else {\n      const result = _.reduce(inV, function (acc, e) {\n        const edge = g.edge(e)\n        const nodeU = g.node(e.v)\n        return {\n          sum: acc.sum + (edge.weight * nodeU.order),\n          weight: acc.weight + edge.weight\n        }\n      }, { sum: 0, weight: 0 })\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      }\n    }\n  })\n}\n\nexport default barycenter\n","import _ from 'lodash'\n\nimport barycenter from './barycenter'\nimport resolveConflicts from './resolve-conflicts'\nimport sort from './sort'\n\nfunction sortSubgraph (g, v, cg, biasRight) {\n  let movable = g.children(v)\n  const node = g.node(v)\n  const bl = node ? node.borderLeft : undefined\n  const br = node ? node.borderRight : undefined\n  const subgraphs = {}\n\n  if (bl) {\n    movable = _.filter(movable, function (w) {\n      return w !== bl && w !== br\n    })\n  }\n\n  const barycenters = barycenter(g, movable)\n  _.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight)\n      subgraphs[entry.v] = subgraphResult\n      if (_.has(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult)\n      }\n    }\n  })\n\n  const entries = resolveConflicts(barycenters, cg)\n  expandSubgraphs(entries, subgraphs)\n\n  const result = sort(entries, biasRight)\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br], true)\n    if (g.predecessors(bl).length) {\n      const blPred = g.node(g.predecessors(bl)[0])\n      const brPred = g.node(g.predecessors(br)[0])\n      if (!_.has(result, 'barycenter')) {\n        result.barycenter = 0\n        result.weight = 0\n      }\n      result.barycenter = (result.barycenter * result.weight +\n                           blPred.order + brPred.order) / (result.weight + 2)\n      result.weight += 2\n    }\n  }\n\n  return result\n}\n\nfunction expandSubgraphs (entries, subgraphs) {\n  _.forEach(entries, function (entry) {\n    entry.vs = _.flatten(entry.vs.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs\n      }\n      return v\n    }), true)\n  })\n}\n\nfunction mergeBarycenters (target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight +\n                         other.barycenter * other.weight) /\n                        (target.weight + other.weight)\n    target.weight += other.weight\n  } else {\n    target.barycenter = other.barycenter\n    target.weight = other.weight\n  }\n}\n\nexport default sortSubgraph\n","import _ from 'lodash'\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount (g, layering) {\n  let cc = 0\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i])\n  }\n  return cc\n}\n\nfunction twoLayerCrossCount (g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = _.zipObject(southLayer,\n    _.map(southLayer, function (v, i) { return i }))\n  const southEntries = _.flatten(_.map(northLayer, function (v) {\n    return _.chain(g.outEdges(v))\n      .map(function (e) {\n        return { pos: southPos[e.w], weight: g.edge(e).weight }\n      })\n      .sortBy('pos')\n      .value()\n  }), true)\n\n  // Build the accumulator tree\n  let firstIndex = 1\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1\n  }\n  const treeSize = 2 * firstIndex - 1\n  firstIndex -= 1\n  const tree = _.map(new Array(treeSize), function () { return 0 })\n\n  // Calculate the weighted crossings\n  let cc = 0\n  _.forEach(southEntries.forEach(function (entry) {\n    let index = entry.pos + firstIndex\n    tree[index] += entry.weight\n    let weightSum = 0\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1]\n      }\n      index = (index - 1) >> 1\n      tree[index] += entry.weight\n    }\n    cc += entry.weight * weightSum\n  }))\n\n  return cc\n}\n\nexport default crossCount\n","import _ from 'lodash'\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder (g) {\n  const visited = {}\n  const simpleNodes = _.filter(g.nodes(), function (v) {\n    return !g.children(v).length\n  })\n  const maxRank = _.max(_.map(simpleNodes, function (v) { return g.node(v).rank }))\n  const layers = _.map(_.range(maxRank + 1), function () { return [] })\n\n  function dfs (v) {\n    if (_.has(visited, v)) return\n    visited[v] = true\n    const node = g.node(v)\n    layers[node.rank].push(v)\n    _.forEach(g.successors(v), dfs)\n  }\n\n  const orderedVs = _.sortBy(simpleNodes, function (v) { return g.node(v).rank })\n  _.forEach(orderedVs, dfs)\n\n  return layers\n}\n\nexport default initOrder\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport initOrder from './init-order'\nimport crossCount from './cross-count'\nimport sortSubgraph from './sort-subgraph'\nimport buildLayerGraph from './build-layer-graph'\nimport addSubgraphConstraints from './add-subgraph-constraints'\nimport util from '../util'\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order (g) {\n  const maxRank = util.maxRank(g)\n  const downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges')\n  const upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges')\n\n  let layering = initOrder(g)\n  assignOrder(g, layering)\n\n  let bestCC = Number.POSITIVE_INFINITY\n  let best\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2)\n\n    layering = util.buildLayerMatrix(g)\n    const cc = crossCount(g, layering)\n    if (cc < bestCC) {\n      lastBest = 0\n      best = _.cloneDeep(layering)\n      bestCC = cc\n    }\n  }\n\n  assignOrder(g, best)\n}\n\nfunction buildLayerGraphs (g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship)\n  })\n}\n\nfunction sweepLayerGraphs (layerGraphs, biasRight) {\n  const cg = new Graph()\n  _.forEach(layerGraphs, function (lg) {\n    const root = lg.graph().root\n    const sorted = sortSubgraph(lg, root, cg, biasRight)\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i\n    })\n    addSubgraphConstraints(lg, cg, sorted.vs)\n  })\n}\n\nfunction assignOrder (g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i\n    })\n  })\n}\n\nexport default order\n","import _ from 'lodash'\n\nfunction adjust (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g)\n  }\n}\n\nfunction undo (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g)\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g)\n    swapWidthHeight(g)\n  }\n}\n\nfunction swapWidthHeight (g) {\n  _.forEach(g.nodes(), function (v) { swapWidthHeightOne(g.node(v)) })\n  _.forEach(g.edges(), function (e) { swapWidthHeightOne(g.edge(e)) })\n}\n\nfunction swapWidthHeightOne (attrs) {\n  const w = attrs.width\n  attrs.width = attrs.height\n  attrs.height = w\n}\n\nfunction reverseY (g) {\n  _.forEach(g.nodes(), function (v) { reverseYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, reverseYOne)\n    if (_.has(edge, 'y')) {\n      reverseYOne(edge)\n    }\n  })\n}\n\nfunction reverseYOne (attrs) {\n  attrs.y = -attrs.y\n}\n\nfunction swapXY (g) {\n  _.forEach(g.nodes(), function (v) { swapXYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, swapXYOne)\n    if (_.has(edge, 'x')) {\n      swapXYOne(edge)\n    }\n  })\n}\n\nfunction swapXYOne (attrs) {\n  const x = attrs.x\n  attrs.x = attrs.y\n  attrs.y = x\n}\n\nexport default {\n  adjust,\n  undo\n}\n","import _ from 'lodash'\n\nimport util from './util'\n\nfunction addBorderSegments (g) {\n  function dfs (v) {\n    const children = g.children(v)\n    const node = g.node(v)\n    if (children.length) {\n      _.forEach(children, dfs)\n    }\n\n    if (_.has(node, 'minRank')) {\n      node.borderLeft = []\n      node.borderRight = []\n      for (let rank = node.minRank, maxRank = node.maxRank + 1;\n        rank < maxRank;\n        ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank)\n        addBorderNode(g, 'borderRight', '_br', v, node, rank)\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs)\n}\n\nfunction addBorderNode (g, prop, prefix, sg, sgNode, rank) {\n  const label = { width: 0, height: 0, rank: rank, borderType: prop }\n  const prev = sgNode[prop][rank - 1]\n  const curr = util.addDummyNode(g, 'border', label, prefix)\n  sgNode[prop][rank] = curr\n  g.setParent(curr, sg)\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 })\n  }\n}\n\nexport default addBorderSegments\n","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run (g) {\n  const root = util.addDummyNode(g, 'root', {}, '_root')\n  const depths = treeDepths(g)\n  const height = _.max(_.values(depths)) - 1\n  const nodeSep = 2 * height + 1\n\n  g.graph().nestingRoot = root\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function (e) { g.edge(e).minlen *= nodeSep })\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  const weight = sumWeights(g) + 1\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n  })\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep\n}\n\nfunction dfs (g, root, nodeSep, weight, height, depths, v) {\n  const children = g.children(v)\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep })\n    }\n    return\n  }\n\n  const top = util.addBorderNode(g, '_bt')\n  const bottom = util.addBorderNode(g, '_bb')\n  const label = g.node(v)\n\n  g.setParent(top, v)\n  label.borderTop = top\n  g.setParent(bottom, v)\n  label.borderBottom = bottom\n\n  _.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n\n    const childNode = g.node(child)\n    const childTop = childNode.borderTop ? childNode.borderTop : child\n    const childBottom = childNode.borderBottom ? childNode.borderBottom : child\n    const thisWeight = childNode.borderTop ? weight : 2 * weight\n    const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n  })\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] })\n  }\n}\n\nfunction treeDepths (g) {\n  const depths = {}\n  function dfs (v, depth) {\n    const children = g.children(v)\n    if (children && children.length) {\n      _.forEach(children, function (child) {\n        dfs(child, depth + 1)\n      })\n    }\n    depths[v] = depth\n  }\n  _.forEach(g.children(), function (v) { dfs(v, 1) })\n  return depths\n}\n\nfunction sumWeights (g) {\n  return _.reduce(g.edges(), function (acc, e) {\n    return acc + g.edge(e).weight\n  }, 0)\n}\n\nfunction cleanup (g) {\n  const graphLabel = g.graph()\n  g.removeNode(graphLabel.nestingRoot)\n  delete graphLabel.nestingRoot\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.nestingEdge) {\n      g.removeEdge(e)\n    }\n  })\n}\n\nexport default {\n  run,\n  cleanup\n}\n","import _ from 'lodash'\n\nfunction parentDummyChains (g) {\n  const postorderNums = postorder(g)\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const edgeObj = node.edgeObj\n    const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w)\n    const path = pathData.path\n    const lca = pathData.lca\n    let pathIdx = 0\n    let pathV = path[pathIdx]\n    let ascending = true\n\n    while (v !== edgeObj.w) {\n      node = g.node(v)\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++\n        }\n\n        if (pathV === lca) {\n          ascending = false\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++\n        }\n        pathV = path[pathIdx]\n      }\n\n      g.setParent(v, pathV)\n      v = g.successors(v)[0]\n    }\n  })\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath (g, postorderNums, v, w) {\n  const vPath = []\n  const wPath = []\n  const low = Math.min(postorderNums[v].low, postorderNums[w].low)\n  const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim)\n  let parent\n  let lca\n\n  // Traverse up from v to find the LCA\n  parent = v\n  do {\n    parent = g.parent(parent)\n    vPath.push(parent)\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim))\n  lca = parent\n\n  // Traverse from w to LCA\n  parent = w\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent)\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca }\n}\n\nfunction postorder (g) {\n  const result = {}\n  let lim = 0\n\n  function dfs (v) {\n    const low = lim\n    _.forEach(g.children(v), dfs)\n    result[v] = { low: low, lim: lim++ }\n  }\n  _.forEach(g.children(), dfs)\n\n  return result\n}\n\nexport default parentDummyChains\n","import _ from 'lodash'\nimport { alg } from 'graphlibrary'\n\nimport feasibleTree from './feasible-tree'\nimport { slack, longestPath as initRank } from './util'\nimport { simplify } from '../util'\n\nconst { preorder, postorder } = alg\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues\nnetworkSimplex.initCutValues = initCutValues\nnetworkSimplex.calcCutValue = calcCutValue\nnetworkSimplex.leaveEdge = leaveEdge\nnetworkSimplex.enterEdge = enterEdge\nnetworkSimplex.exchangeEdges = exchangeEdges\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex (g) {\n  g = simplify(g)\n  initRank(g)\n  const t = feasibleTree(g)\n  initLowLimValues(t)\n  initCutValues(t, g)\n\n  let e\n  let f\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e)\n    exchangeEdges(t, g, e, f)\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues (t, g) {\n  let vs = postorder(t, t.nodes())\n  vs = vs.slice(0, vs.length - 1)\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v)\n  })\n}\n\nfunction assignCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child)\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true\n  // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.edge(child, parent)\n  // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0\n\n  if (!graphEdge) {\n    childIsTail = false\n    graphEdge = g.edge(parent, child)\n  }\n\n  cutValue = graphEdge.weight\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    const isOutEdge = e.v === child\n    const other = isOutEdge ? e.w : e.v\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail\n      const otherWeight = g.edge(e).weight\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edge(child, other).cutvalue\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue\n      }\n    }\n  })\n\n  return cutValue\n}\n\nfunction initLowLimValues (tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0]\n  }\n  dfsAssignLowLim(tree, {}, 1, root)\n}\n\nfunction dfsAssignLowLim (tree, visited, nextLim, v, parent) {\n  const low = nextLim\n  const label = tree.node(v)\n\n  visited[v] = true\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v)\n    }\n  })\n\n  label.low = low\n  label.lim = nextLim++\n  if (parent) {\n    label.parent = parent\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent\n  }\n\n  return nextLim\n}\n\nfunction leaveEdge (tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0\n  })\n}\n\nfunction enterEdge (t, g, edge) {\n  let v = edge.v\n  let w = edge.w\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w\n    w = edge.v\n  }\n\n  const vLabel = t.node(v)\n  const wLabel = t.node(w)\n  let tailLabel = vLabel\n  let flip = false\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel\n    flip = true\n  }\n\n  const candidates = _.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel)\n  })\n\n  return _.minBy(candidates, function (edge) { return slack(g, edge) })\n}\n\nfunction exchangeEdges (t, g, e, f) {\n  const v = e.v\n  const w = e.w\n  t.removeEdge(v, w)\n  t.setEdge(f.v, f.w, {})\n  initLowLimValues(t)\n  initCutValues(t, g)\n  updateRanks(t, g)\n}\n\nfunction updateRanks (t, g) {\n  const root = _.find(t.nodes(), function (v) { return !g.node(v).parent })\n  let vs = preorder(t, root)\n  vs = vs.slice(1)\n  _.forEach(vs, function (v) {\n    const parent = t.node(v).parent\n    let edge = g.edge(v, parent)\n    let flipped = false\n\n    if (!edge) {\n      edge = g.edge(parent, v)\n      flipped = true\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen)\n  })\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge (tree, u, v) {\n  return tree.hasEdge(u, v)\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim\n}\n\nexport default networkSimplex\n","import { longestPath } from './util'\nimport feasibleTree from './feasible-tree'\nimport networkSimplex from './network-simplex'\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank (g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex': networkSimplexRanker(g); break\n    case 'tight-tree': tightTreeRanker(g); break\n    case 'longest-path': longestPathRanker(g); break\n    default: networkSimplexRanker(g)\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nconst longestPathRanker = longestPath\n\nfunction tightTreeRanker (g) {\n  longestPath(g)\n  feasibleTree(g)\n}\n\nfunction networkSimplexRanker (g) {\n  networkSimplex(g)\n}\n\nexport default rank\n","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run (g) {\n  g.graph().dummyChains = []\n  _.forEach(g.edges(), function (edge) { normalizeEdge(g, edge) })\n}\n\nfunction normalizeEdge (g, e) {\n  let v = e.v\n  let vRank = g.node(v).rank\n  const w = e.w\n  const wRank = g.node(w).rank\n  const name = e.name\n  const edgeLabel = g.edge(e)\n  const labelRank = edgeLabel.labelRank\n\n  if (wRank === vRank + 1) return\n\n  g.removeEdge(e)\n\n  let dummy\n  let attrs\n  let i\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = []\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank\n    }\n    dummy = util.addDummyNode(g, 'edge', attrs, '_d')\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width\n      attrs.height = edgeLabel.height\n      attrs.dummy = 'edge-label'\n      attrs.labelpos = edgeLabel.labelpos\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name)\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy)\n    }\n    v = dummy\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name)\n}\n\nfunction undo (g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const origLabel = node.edgeLabel\n    let w = null\n    g.setEdge(node.edgeObj, origLabel)\n    while (node.dummy) {\n      w = g.successors(v)[0]\n      g.removeNode(v)\n      origLabel.points.push({ x: node.x, y: node.y })\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x\n        origLabel.y = node.y\n        origLabel.width = node.width\n        origLabel.height = node.height\n      }\n      v = w\n      node = g.node(v)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n","/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nfunction List () {\n  const sentinel = {}\n  sentinel._next = sentinel._prev = sentinel\n  this._sentinel = sentinel\n}\n\nList.prototype.dequeue = function () {\n  const sentinel = this._sentinel\n  const entry = sentinel._prev\n  if (entry !== sentinel) {\n    unlink(entry)\n    return entry\n  }\n}\n\nList.prototype.enqueue = function (entry) {\n  const sentinel = this._sentinel\n  if (entry._prev && entry._next) {\n    unlink(entry)\n  }\n  entry._next = sentinel._next\n  sentinel._next._prev = entry\n  sentinel._next = entry\n  entry._prev = sentinel\n}\n\nList.prototype.toString = function () {\n  const strs = []\n  const sentinel = this._sentinel\n  let curr = sentinel._prev\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks))\n    curr = curr._prev\n  }\n  return '[' + strs.join(', ') + ']'\n}\n\nfunction unlink (entry) {\n  entry._prev._next = entry._next\n  entry._next._prev = entry._prev\n  delete entry._next\n  delete entry._prev\n}\n\nfunction filterOutLinks (k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v\n  }\n}\n\nexport default List\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport List from './data/list'\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\nconst DEFAULT_WEIGHT_FN = _.constant(1)\n\nfunction greedyFAS (g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return []\n  }\n  const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN)\n  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx)\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function (e) {\n    return g.outEdges(e.v, e.w)\n  }), true)\n}\n\nfunction doGreedyFAS (g, buckets, zeroIdx) {\n  let results = []\n  const sources = buckets[buckets.length - 1]\n  const sinks = buckets[0]\n\n  let entry\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    if (g.nodeCount()) {\n      for (let i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue()\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true))\n          break\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nfunction removeNode (g, buckets, zeroIdx, entry, collectPredecessors) {\n  const results = collectPredecessors ? [] : undefined\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const uEntry = g.node(edge.v)\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w })\n    }\n\n    uEntry.out -= weight\n    assignBucket(buckets, zeroIdx, uEntry)\n  })\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const w = edge.w\n    const wEntry = g.node(w)\n    wEntry['in'] -= weight\n    assignBucket(buckets, zeroIdx, wEntry)\n  })\n\n  g.removeNode(entry.v)\n\n  return results\n}\n\nfunction buildState (g, weightFn) {\n  const fasGraph = new Graph()\n  let maxIn = 0\n  let maxOut = 0\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, 'in': 0, out: 0 })\n  })\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function (e) {\n    const prevWeight = fasGraph.edge(e.v, e.w) || 0\n    const weight = weightFn(e)\n    const edgeWeight = prevWeight + weight\n    fasGraph.setEdge(e.v, e.w, edgeWeight)\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight)\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)['in'] += weight)\n  })\n\n  const buckets = _.range(maxOut + maxIn + 3).map(function () { return new List() })\n  const zeroIdx = maxIn + 1\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v))\n  })\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx }\n}\n\nfunction assignBucket (buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry)\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry)\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry)\n  }\n}\n\nexport default greedyFAS\n","import _ from 'lodash'\n\nimport greedyFAS from './greedy-fas'\n\nfunction run (g) {\n  const fas = (g.graph().acyclicer === 'greedy'\n    ? greedyFAS(g, weightFn(g))\n    : dfsFAS(g))\n  _.forEach(fas, function (e) {\n    const label = g.edge(e)\n    g.removeEdge(e)\n    label.forwardName = e.name\n    label.reversed = true\n    g.setEdge(e.w, e.v, label, _.uniqueId('rev'))\n  })\n\n  function weightFn (g) {\n    return function (e) {\n      return g.edge(e).weight\n    }\n  }\n}\n\nfunction dfsFAS (g) {\n  const fas = []\n  const stack = {}\n  const visited = {}\n\n  function dfs (v) {\n    if (_.has(visited, v)) {\n      return\n    }\n    visited[v] = true\n    stack[v] = true\n    _.forEach(g.outEdges(v), function (e) {\n      if (_.has(stack, e.w)) {\n        fas.push(e)\n      } else {\n        dfs(e.w)\n      }\n    })\n    delete stack[v]\n  }\n\n  _.forEach(g.nodes(), dfs)\n  return fas\n}\n\nfunction undo (g) {\n  _.forEach(g.edges(), function (e) {\n    const label = g.edge(e)\n    if (label.reversed) {\n      g.removeEdge(e)\n\n      const forwardName = label.forwardName\n      delete label.reversed\n      delete label.forwardName\n      g.setEdge(e.w, e.v, label, forwardName)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport acyclic from './acyclic'\nimport normalize from './normalize'\nimport rank from './rank'\nimport util, { normalizeRanks, removeEmptyRanks } from './util'\nimport parentDummyChains from './parent-dummy-chains'\nimport nestingGraph from './nesting-graph'\nimport addBorderSegments from './add-border-segments'\nimport coordinateSystem from './coordinate-system'\nimport order from './order'\nimport position from './position'\n\nfunction layout (g, opts) {\n  const time = opts && opts.debugTiming ? util.time : util.notime\n  time('layout', function () {\n    const layoutGraph = time('  buildLayoutGraph',\n      function () { return buildLayoutGraph(g) })\n    time('  runLayout', function () { runLayout(layoutGraph, time) })\n    time('  updateInputGraph', function () { updateInputGraph(g, layoutGraph) })\n  })\n}\n\nfunction runLayout (g, time) {\n  time('    makeSpaceForEdgeLabels', function () { makeSpaceForEdgeLabels(g) })\n  time('    removeSelfEdges', function () { removeSelfEdges(g) })\n  time('    acyclic', function () { acyclic.run(g) })\n  time('    nestingGraph.run', function () { nestingGraph.run(g) })\n  time('    rank', function () { rank(util.asNonCompoundGraph(g)) })\n  time('    injectEdgeLabelProxies', function () { injectEdgeLabelProxies(g) })\n  time('    removeEmptyRanks', function () { removeEmptyRanks(g) })\n  time('    nestingGraph.cleanup', function () { nestingGraph.cleanup(g) })\n  time('    normalizeRanks', function () { normalizeRanks(g) })\n  time('    assignRankMinMax', function () { assignRankMinMax(g) })\n  time('    removeEdgeLabelProxies', function () { removeEdgeLabelProxies(g) })\n  time('    normalize.run', function () { normalize.run(g) })\n  time('    parentDummyChains', function () { parentDummyChains(g) })\n  time('    addBorderSegments', function () { addBorderSegments(g) })\n  time('    order', function () { order(g) })\n  time('    insertSelfEdges', function () { insertSelfEdges(g) })\n  time('    adjustCoordinateSystem', function () { coordinateSystem.adjust(g) })\n  time('    position', function () { position(g) })\n  time('    positionSelfEdges', function () { positionSelfEdges(g) })\n  time('    removeBorderNodes', function () { removeBorderNodes(g) })\n  time('    normalize.undo', function () { normalize.undo(g) })\n  time('    fixupEdgeLabelCoords', function () { fixupEdgeLabelCoords(g) })\n  time('    undoCoordinateSystem', function () { coordinateSystem.undo(g) })\n  time('    translateGraph', function () { translateGraph(g) })\n  time('    assignNodeIntersects', function () { assignNodeIntersects(g) })\n  time('    reversePoints', function () { reversePointsForReversedEdges(g) })\n  time('    acyclic.undo', function () { acyclic.undo(g) })\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph (inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    const inputLabel = inputGraph.node(v)\n    const layoutLabel = layoutGraph.node(v)\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width\n        inputLabel.height = layoutLabel.height\n      }\n    }\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const inputLabel = inputGraph.edge(e)\n    const layoutLabel = layoutGraph.edge(e)\n\n    inputLabel.points = layoutLabel.points\n    if (_.has(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n    }\n  })\n\n  inputGraph.graph().width = layoutGraph.graph().width\n  inputGraph.graph().height = layoutGraph.graph().height\n}\n\nconst graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy']\nconst graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' }\nconst graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align']\nconst nodeNumAttrs = ['width', 'height']\nconst nodeDefaults = { width: 0, height: 0 }\nconst edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset']\nconst edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r'\n}\nconst edgeAttrs = ['labelpos']\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph (inputGraph) {\n  const g = new Graph({ multigraph: true, compound: true })\n  const graph = canonicalize(inputGraph.graph())\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)))\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    const node = canonicalize(inputGraph.node(v))\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults))\n    g.setParent(v, inputGraph.parent(v))\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const edge = canonicalize(inputGraph.edge(e))\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)))\n  })\n\n  return g\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels (g) {\n  const graph = g.graph()\n  graph.ranksep /= 2\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    edge.minlen *= 2\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset\n      } else {\n        edge.height += edge.labeloffset\n      }\n    }\n  })\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.width && edge.height) {\n      const v = g.node(e.v)\n      const w = g.node(e.w)\n      const label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e }\n      util.addDummyNode(g, 'edge-proxy', label, '_ep')\n    }\n  })\n}\n\nfunction assignRankMinMax (g) {\n  let maxRank = 0\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank\n      node.maxRank = g.node(node.borderBottom).rank\n      maxRank = Math.max(maxRank, node.maxRank)\n    }\n  })\n  g.graph().maxRank = maxRank\n}\n\nfunction removeEdgeLabelProxies (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction translateGraph (g) {\n  let minX = Number.POSITIVE_INFINITY\n  let maxX = 0\n  let minY = Number.POSITIVE_INFINITY\n  let maxY = 0\n  const graphLabel = g.graph()\n  const marginX = graphLabel.marginx || 0\n  const marginY = graphLabel.marginy || 0\n\n  function getExtremes (attrs) {\n    const x = attrs.x\n    const y = attrs.y\n    const w = attrs.width\n    const h = attrs.height\n    minX = Math.min(minX, x - w / 2)\n    maxX = Math.max(maxX, x + w / 2)\n    minY = Math.min(minY, y - h / 2)\n    maxY = Math.max(maxY, y + h / 2)\n  }\n\n  _.forEach(g.nodes(), function (v) { getExtremes(g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      getExtremes(edge)\n    }\n  })\n\n  minX -= marginX\n  minY -= marginY\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    node.x -= minX\n    node.y -= minY\n  })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, function (p) {\n      p.x -= minX\n      p.y -= minY\n    })\n    if (_.has(edge, 'x')) { edge.x -= minX }\n    if (_.has(edge, 'y')) { edge.y -= minY }\n  })\n\n  graphLabel.width = maxX - minX + marginX\n  graphLabel.height = maxY - minY + marginY\n}\n\nfunction assignNodeIntersects (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    const nodeV = g.node(e.v)\n    const nodeW = g.node(e.w)\n    let p1 = null\n    let p2 = null\n    if (!edge.points) {\n      edge.points = []\n      p1 = nodeW\n      p2 = nodeV\n    } else {\n      p1 = edge.points[0]\n      p2 = edge.points[edge.points.length - 1]\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1))\n    edge.points.push(util.intersectRect(nodeW, p2))\n  })\n}\n\nfunction fixupEdgeLabelCoords (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset\n      }\n      switch (edge.labelpos) {\n        case 'l': edge.x -= edge.width / 2 + edge.labeloffset; break\n        case 'r': edge.x += edge.width / 2 + edge.labeloffset; break\n      }\n    }\n  })\n}\n\nfunction reversePointsForReversedEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.reversed) {\n      edge.points.reverse()\n    }\n  })\n}\n\nfunction removeBorderNodes (g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      const node = g.node(v)\n      const t = g.node(node.borderTop)\n      const b = g.node(node.borderBottom)\n      const l = g.node(_.last(node.borderLeft))\n      const r = g.node(_.last(node.borderRight))\n\n      node.width = Math.abs(r.x - l.x)\n      node.height = Math.abs(b.y - t.y)\n      node.x = l.x + node.width / 2\n      node.y = t.y + node.height / 2\n    }\n  })\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction removeSelfEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      const node = g.node(e.v)\n      if (!node.selfEdges) {\n        node.selfEdges = []\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) })\n      g.removeEdge(e)\n    }\n  })\n}\n\nfunction insertSelfEdges (g) {\n  const layers = util.buildLayerMatrix(g)\n  _.forEach(layers, function (layer) {\n    let orderShift = 0\n    _.forEach(layer, function (v, i) {\n      const node = g.node(v)\n      node.order = i + orderShift\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(g, 'selfedge', {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, '_se')\n      })\n      delete node.selfEdges\n    })\n  })\n}\n\nfunction positionSelfEdges (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'selfedge') {\n      const selfNode = g.node(node.e.v)\n      const x = selfNode.x + selfNode.width / 2\n      const y = selfNode.y\n      const dx = node.x - x\n      const dy = selfNode.height / 2\n      g.setEdge(node.e, node.label)\n      g.removeNode(v)\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x + dx, y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ]\n      node.label.x = node.x\n      node.label.y = node.y\n    }\n  })\n}\n\nfunction selectNumberAttrs (obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number)\n}\n\nfunction canonicalize (attrs) {\n  const newAttrs = {}\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v\n  })\n  return newAttrs\n}\n\nexport default layout\n","import layout from './lib/layout'\n\nexport default {\n  layout\n}\n"],"sourceRoot":""}